import React from 'react';
import { Router, __RouterContext, Route } from 'react-router';
export * from 'react-router';
import { createBrowserHistory, createHashHistory, createLocation } from 'history';
import PropTypes from 'prop-types';
import warning from 'warning';
import invariant from 'invariant';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createBrowserHistory(_this.props), _temp), possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.render = function render() {
    return React.createElement(Router, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(React.Component);

if (process.env.NODE_ENV !== "production") {
  BrowserRouter.propTypes = {
    basename: PropTypes.string,
    children: PropTypes.node,
    forceRefresh: PropTypes.bool,
    getUserConfirmation: PropTypes.func,
    keyLength: PropTypes.number
  };

  BrowserRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
  };
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHashHistory(_this.props), _temp), possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.render = function render() {
    return React.createElement(Router, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(React.Component);

if (process.env.NODE_ENV !== "production") {
  HashRouter.propTypes = {
    basename: PropTypes.string,
    children: PropTypes.node,
    getUserConfirmation: PropTypes.func,
    hashType: PropTypes.oneOf(["hashbang", "noslash", "slash"])
  };

  HashRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
  };
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  inherits(Link, _React$Component);

  function Link() {
    classCallCheck(this, Link);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Link.prototype.handleClick = function handleClick(event, context) {
    if (this.props.onClick) this.props.onClick(event);

    if (!event.defaultPrevented && // onClick prevented default
    event.button === 0 && ( // ignore everything but left clicks
    !this.props.target || this.props.target === "_self") && // let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // ignore clicks with modifier keys
    ) {
        event.preventDefault();

        var method = this.props.replace ? context.history.replace : context.history.push;

        method(this.props.to);
      }
  };

  Link.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        innerRef = _props.innerRef,
        replace = _props.replace,
        to = _props.to,
        props = objectWithoutProperties(_props, ["innerRef", "replace", "to"]); // eslint-disable-line no-unused-vars

    return React.createElement(
      __RouterContext.Consumer,
      null,
      function (context) {
        !context ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Link> outside a <Router>") : invariant(false) : void 0;

        var location = typeof to === "string" ? createLocation(to, null, null, context.location) : to;
        var href = location ? context.history.createHref(location) : "";

        return React.createElement("a", _extends({}, props, {
          onClick: function onClick(event) {
            return _this2.handleClick(event, context);
          },
          href: href,
          ref: innerRef
        }));
      }
    );
  };

  return Link;
}(React.Component);

Link.defaultProps = {
  replace: false
};


if (process.env.NODE_ENV !== "production") {
  var toType = PropTypes.oneOfType([PropTypes.string, PropTypes.object]);

  Link.propTypes = {
    innerRef: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    onClick: PropTypes.func,
    replace: PropTypes.bool,
    target: PropTypes.string,
    to: toType.isRequired
  };
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
function NavLink(_ref) {
  var ariaCurrent = _ref["aria-current"],
      activeClassName = _ref.activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      location = _ref.location,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      rest = objectWithoutProperties(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "strict", "style", "to"]);

  var path = (typeof to === "undefined" ? "undefined" : _typeof(to)) === "object" ? to.pathname : to;

  // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202
  var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");

  return React.createElement(Route, {
    path: escapedPath,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(isActiveProp ? isActiveProp(match, location) : match);

      var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
      var style = isActive ? Object.assign({}, styleProp, activeStyle) : styleProp;

      return React.createElement(Link, _extends({
        "aria-current": isActive && ariaCurrent || null,
        className: className,
        style: style,
        to: to
      }, rest));
    }
  });
}

NavLink.defaultProps = {
  "aria-current": "page",
  activeClassName: "active"
};

if (process.env.NODE_ENV !== "production") {
  var ariaCurrentType = PropTypes.oneOf(["page", "step", "location", "date", "time", "true"]);

  NavLink.propTypes = {
    "aria-current": ariaCurrentType,
    activeClassName: PropTypes.string,
    activeStyle: PropTypes.object,
    className: PropTypes.string,
    exact: Route.propTypes.exact,
    isActive: PropTypes.func,
    location: PropTypes.object,
    strict: Route.propTypes.strict,
    style: PropTypes.object,
    to: Link.propTypes.to
  };
}

export { BrowserRouter, HashRouter, Link, NavLink };
