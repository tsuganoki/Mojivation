import createContext from 'create-react-context';
import warning from 'warning';
import React from 'react';
import PropTypes from 'prop-types';
import { createMemoryHistory, createLocation, locationsAreEqual, createPath } from 'history';
import invariant from 'invariant';
import pathToRegexp from 'path-to-regexp';
import hoistStatics from 'hoist-non-react-statics';

// TODO: Replace with React.createContext once we can assume React 16+

var context = createContext();

context.Provider.displayName = "Router.Provider";
context.Consumer.displayName = "Router.Consumer";

var warnAboutGettingProperty = function warnAboutGettingProperty() {};
if (process.env.NODE_ENV !== "production") {
  warnAboutGettingProperty = function warnAboutGettingProperty(object, key, message) {
    var didIssueWarning = false;

    var value = object[key];

    Object.defineProperty(object, key, {
      get: function get() {
        if (!didIssueWarning) {
          process.env.NODE_ENV !== "production" ? warning(false, message) : void 0;
          didIssueWarning = true;
        }

        return value;
      },
      configurable: true
    });
  };
}

var warnAboutGettingProperty$1 = warnAboutGettingProperty;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function getContext(props, state) {
  return {
    history: props.history,
    location: state.location,
    match: Router.computeRootMatch(state.location.pathname),
    staticContext: props.staticContext
  };
}

/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  inherits(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return { path: "/", url: "/", params: {}, isExact: pathname === "/" };
  };

  function Router(props) {
    classCallCheck(this, Router);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      location: props.history.location
    };

    // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.
    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({ location: location });
        } else {
          _this._pendingLocation = location;
        }
      });
    }
    return _this;
  }

  Router.prototype.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({ location: this._pendingLocation });
    }
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };

  Router.prototype.render = function render() {
    var context$$1 = getContext(this.props, this.state);

    return React.createElement(context.Provider, {
      children: this.props.children || null,
      value: context$$1
    });
  };

  return Router;
}(React.Component);

// TODO: Remove this in v5


if (!React.createContext) {
  Router.childContextTypes = {
    router: PropTypes.object.isRequired
  };

  Router.prototype.getChildContext = function () {
    var context$$1 = getContext(this.props, this.state);

    if (process.env.NODE_ENV !== "production") {
      var contextWithoutWarnings = Object.assign({}, context$$1);

      Object.keys(context$$1).forEach(function (key) {
        warnAboutGettingProperty$1(context$$1, key, "You should not be using this.context.router." + key + " directly. It is private API " + "for internal use only and is subject to change at any time. Instead, use " + "a <Route> or withRouter() to access the current location, match, etc.");
      });

      context$$1._withoutWarnings = contextWithoutWarnings;
    }

    return {
      router: context$$1
    };
  };
}

if (process.env.NODE_ENV !== "production") {
  Router.propTypes = {
    children: PropTypes.node,
    history: PropTypes.object.isRequired,
    staticContext: PropTypes.object
  };

  Router.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
  };
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createMemoryHistory(_this.props), _temp), possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.render = function render() {
    return React.createElement(Router, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(React.Component);

if (process.env.NODE_ENV !== "production") {
  MemoryRouter.propTypes = {
    initialEntries: PropTypes.array,
    initialIndex: PropTypes.number,
    getUserConfirmation: PropTypes.func,
    keyLength: PropTypes.number,
    children: PropTypes.node
  };

  MemoryRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
  };
}

var Lifecycle = function (_React$Component) {
  inherits(Lifecycle, _React$Component);

  function Lifecycle() {
    classCallCheck(this, Lifecycle);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Lifecycle.prototype.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  Lifecycle.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  Lifecycle.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  Lifecycle.prototype.render = function render() {
    return null;
  };

  return Lifecycle;
}(React.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */
function Prompt(props) {
  return React.createElement(
    context.Consumer,
    null,
    function (context$$1) {
      !context$$1 ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Prompt> outside a <Router>") : invariant(false) : void 0;

      if (!props.when || context$$1.staticContext) return null;

      var method = context$$1.history.block;
      var message = props.message;

      return React.createElement(Lifecycle, {
        onMount: function onMount(self) {
          self.release = method(message);
        },
        onUpdate: function onUpdate(self, prevProps) {
          if (prevProps.message !== message) {
            self.release();
            self.release = method(message);
          }
        },
        onUnmount: function onUnmount(self) {
          self.release();
        }
      });
    }
  );
}

Prompt.defaultProps = {
  when: true
};

if (process.env.NODE_ENV !== "production") {
  var messageType = PropTypes.oneOfType([PropTypes.func, PropTypes.string]);

  Prompt.propTypes = {
    when: PropTypes.bool,
    message: messageType.isRequired
  };
}

var cache = {};
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];

  var generator = pathToRegexp.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}

/**
 * Public API for generating a URL pathname from a path and parameters.
 */
function generatePath() {
  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return path === "/" ? path : compilePath(path)(params, { pretty: true });
}

/**
 * The public API for navigating programmatically with a component.
 */
function Redirect(props) {
  return React.createElement(
    context.Consumer,
    null,
    function (context$$1) {
      !context$$1 ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Redirect> outside a <Router>") : invariant(false) : void 0;

      var method = props.push ? context$$1.history.push : context$$1.history.replace;
      var to = createLocation(props.computedMatch ? typeof props.to === "string" ? generatePath(props.to, props.computedMatch.params) : Object.assign({}, props.to, {
        pathname: generatePath(props.to.pathname, props.computedMatch.params)
      }) : props.to);

      // When rendering in a static context,
      // set the new location immediately.
      if (context$$1.staticContext) {
        method(to);
        return null;
      }

      return React.createElement(Lifecycle, {
        onMount: function onMount() {
          method(to);
        },
        onUpdate: function onUpdate(self, prevProps) {
          if (!locationsAreEqual(prevProps.to, to)) {
            method(to);
          }
        },
        to: to
      });
    }
  );
}

Redirect.defaultProps = {
  push: false
};

if (process.env.NODE_ENV !== "production") {
  Redirect.propTypes = {
    push: PropTypes.bool,
    from: PropTypes.string,
    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired
  };
}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});

  if (pathCache[path]) return pathCache[path];

  var keys = [];
  var regexp = pathToRegexp(path, keys, options);
  var result = { regexp: regexp, keys: keys };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}

/**
 * Public API for matching a URL pathname to a path.
 */
function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === "string") options = { path: options };

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;


  var paths = [].concat(path);

  return paths.reduce(function (matched, path) {
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);

    if (!match) return null;

    var url = match[0],
        values = match.slice(1);

    var isExact = pathname === url;

    if (exact && !isExact) return null;

    return {
      path: path, // the path used to match
      url: path === "/" && url === "" ? "/" : url, // the matched portion of the URL
      isExact: isExact, // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}

function getContext$1(props, context$$1) {
  var location = props.location || context$$1.location;
  var match = props.computedMatch ? props.computedMatch // <Switch> already computed the match for us
  : props.path ? matchPath(location.pathname, props) : context$$1.match;

  return Object.assign({}, context$$1, { location: location, match: match });
}

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  inherits(Route, _React$Component);

  function Route() {
    classCallCheck(this, Route);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Route.prototype.render = function render() {
    var _this2 = this;

    return React.createElement(
      context.Consumer,
      null,
      function (context$$1) {
        !context$$1 ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;

        var props = getContext$1(_this2.props, context$$1);

        var _props = _this2.props,
            children = _props.children,
            component = _props.component,
            render = _props.render;

        // Preact uses an empty array as children by
        // default, so use null if that's the case.

        if (Array.isArray(children) && children.length === 0) {
          children = null;
        }

        if (typeof children === "function") {
          children = children(props);

          if (children === undefined) {
            if (process.env.NODE_ENV !== "production") {
              var path = _this2.props.path;


              process.env.NODE_ENV !== "production" ? warning(false, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? " path=\"" + path + "\"" : "") + ">, but you ") + "should have returned a React element or `null`") : void 0;
            }

            children = null;
          }
        }

        return React.createElement(
          context.Provider,
          { value: props },
          children && !isEmptyChildren(children) ? children : props.match ? component ? React.createElement(component, props) : render ? render(props) : null : null
        );
      }
    );
  };

  return Route;
}(React.Component);

// TODO: Remove this in v5


if (!React.createContext) {
  Route.contextTypes = {
    router: PropTypes.object.isRequired
  };

  Route.childContextTypes = {
    router: PropTypes.object.isRequired
  };

  Route.prototype.getChildContext = function () {
    !this.context.router ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;

    var parentContext = this.context.router;
    if (process.env.NODE_ENV !== "production") {
      parentContext = parentContext._withoutWarnings;
    }

    var context$$1 = getContext$1(this.props, parentContext);
    if (process.env.NODE_ENV !== "production") {
      var contextWithoutWarnings = Object.assign({}, context$$1);

      Object.keys(context$$1).forEach(function (key) {
        warnAboutGettingProperty$1(context$$1, key, "You should not be using this.context.router." + key + " directly. It is private API " + "for internal use only and is subject to change at any time. Instead, use " + "a <Route> or withRouter() to access the current location, match, etc.");
      });

      context$$1._withoutWarnings = contextWithoutWarnings;
    }

    return {
      router: context$$1
    };
  };
}

if (process.env.NODE_ENV !== "production") {
  Route.propTypes = {
    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    component: PropTypes.func,
    exact: PropTypes.bool,
    location: PropTypes.object,
    path: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    render: PropTypes.func,
    sensitive: PropTypes.bool,
    strict: PropTypes.bool
  };

  Route.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;

    process.env.NODE_ENV !== "production" ? warning(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;

    process.env.NODE_ENV !== "production" ? warning(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
  };

  Route.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;

    process.env.NODE_ENV !== "production" ? warning(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;

  return Object.assign({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;

  var base = addLeadingSlash(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return Object.assign({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}

function staticHandler(methodName) {
  return function () {
    process.env.NODE_ENV !== "production" ? invariant(false, "You cannot %s with <StaticRouter>", methodName) : invariant(false);
  };
}

function noop() {}

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return addLeadingSlash(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = "PUSH";
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = "REPLACE";
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = objectWithoutProperties(_props, ["basename", "context", "location"]);


    var history = {
      createHref: this.createHref,
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return React.createElement(Router, _extends({}, props, {
      history: history,
      staticContext: this.props.context || {}
    }));
  };

  return StaticRouter;
}(React.Component);

StaticRouter.defaultProps = {
  basename: "",
  location: "/"
};


if (process.env.NODE_ENV !== "production") {
  StaticRouter.propTypes = {
    basename: PropTypes.string,
    context: PropTypes.object,
    location: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
  };

  StaticRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
  };
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  inherits(Switch, _React$Component);

  function Switch() {
    classCallCheck(this, Switch);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.render = function render() {
    var _this2 = this;

    return React.createElement(
      context.Consumer,
      null,
      function (context$$1) {
        !context$$1 ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Switch> outside a <Router>") : invariant(false) : void 0;

        var location = _this2.props.location || context$$1.location;

        var element = void 0,
            match = void 0;

        // We use React.Children.forEach instead of React.Children.toArray().find()
        // here because toArray adds keys to all child elements and we do not want
        // to trigger an unmount/remount for two <Route>s that render the same
        // component at different URLs.
        React.Children.forEach(_this2.props.children, function (child) {
          if (match == null && React.isValidElement(child)) {
            element = child;

            var path = child.props.path || child.props.from;

            match = path ? matchPath(location.pathname, Object.assign({}, child.props, { path: path })) : context$$1.match;
          }
        });

        return match ? React.cloneElement(element, { location: location, computedMatch: match }) : null;
      }
    );
  };

  return Switch;
}(React.Component);

if (process.env.NODE_ENV !== "production") {
  Switch.propTypes = {
    children: PropTypes.node,
    location: PropTypes.object
  };

  Switch.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;

    process.env.NODE_ENV !== "production" ? warning(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}

/**
 * A public higher-order component to access the imperative API
 */
function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = objectWithoutProperties(props, ["wrappedComponentRef"]);


    return React.createElement(Route, {
      children: function children(routeComponentProps) {
        return React.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
          ref: wrappedComponentRef
        }));
      }
    });
  };

  C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  C.WrappedComponent = Component;

  if (process.env.NODE_ENV !== "production") {
    C.propTypes = {
      wrappedComponentRef: PropTypes.func
    };
  }

  return hoistStatics(C, Component);
}

export { MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, generatePath, matchPath, withRouter, context as __RouterContext };
